Select  ProductName, (Price- COALESCE(Discount, 0))AS Final_Price  
from Products;
-------------------------------
Select *
FROM Employees
WHERE HireDate >= '2023-01-01' 
  AND HireDate < '2024-01-01';

--Why is this "The Pro Way"?
--Index Friendly: Using LIKE '%2023%' or YEAR(HireDate) forces the database to look 
--at every single row one by one (slow). Using >= and < allows the database
-- to use an "Index" to jump straight to the 2023 section (fast).

--The Time Trap: Notice 'David' in my setup has a time of 23:59:59. If you only used BETWEEN 
--'2023-01-01' AND '2023-12-31', you might accidentally miss people hired in those last few hours!
--Using < '2024-01-01' catches every single second of 2023.


Select * from Courses;

--1Show all Student Names and their GPA. If a student doesn't have an Advisor (AdvisorID is NULL), show the word 'NONE'.
Select Students.Name , Students.GPA, COALESCE(AdvisorID, 'NONE') as Test FROM Students;


--2.Find all Departments in the Courses table that offer more than 5 total credits across all their courses.
SELECT Department, SUM(Credits) as Total_Credits
FROM Courses
GROUP BY Department
HAVING SUM(Credits) > 5;
--3.Find the names of all Students who are not enrolled in any courses.
SELECT s.Name 
FROM Students s 
LEFT JOIN Enrollments e
ON s.StudentID = e.StudentID
WHERE e.CourseID is NULL;
--4.Find the Name of the student with the highest GPA in the 'CS' Major.
Select *
FROM Students s
WHERE s.Major  = 'CS'
Order by s.GPA DESC;
--5. The Goal: Show a list of all CourseNames and the total number of students enrolled in each.
Select c.CourseName, Count(StudentID) as Total_Students
FROM Courses c 
LEFT JOIN Enrollments e 
ON c.CourseID  = e.CourseID
Group by c.CourseName;
--6.  Write a query that shows the Student Name and their Advisor's Name side-by-side.

Select s2.Name as Student_name, s1.Name as Advisor_Name 
FROM Students s1
JOIN Students s2
ON s2.AdvisorID  = s1.StudentID;

--7) 1. Find the Average GPA for each Major. 
--2. Then, show only the Students whose GPA is higher than their Major's average.
--Select Name, GPA
--FROM Students s 
--Where GPA > (Select AVG(s.GPA)
--FRom Students s) 
----
WITH AVG_GPA AS (
    SELECT AVG(GPA) as Global_Avg FROM Students
)
SELECT s.Name, s.GPA
FROM Students s, AVG_GPA  -- This acts like a join
WHERE s.GPA > AVG_GPA.Global_Avg;

--8. Find the names of students who are enrolled in 'Intro to SQL' (CourseID 101) without using a JOIN.
Select s.Name 
FROM Students s 
Where s.StudentID  IN (Select s.StudentID 
FROM Enrollments e
WHere e.CourseID = 101);
--9. Find any Names that appear more than once in the Students table.
SELECT Name
FROM Students
GROUP BY Name
HAVING COUNT(*) > 1;

WITH RankedData AS (
    SELECT Name, 
           DENSE_RANK() OVER(ORDER BY GPA DESC) as Rnk
    FROM Students
)
SELECT Name, Rnk
FROM RankedData
WHERE Rnk > 2;

--Mock Interview Mode:

--1.We have a Sales table. Some rows have a NULL in the Commission column. If I run SELECT Price + Commission FROM Sales, 
--what happens to the rows where Commission is NULL, and how do you fix it?
--When we add Price and commission, since the comission is having null the final op will have null values because there is no value fro null, so we use the function called Coalase to make the null into 0


--2.What is the difference between a JOIN (Inner) and a LEFT JOIN? Give me a real-world example from our University database.
--When you do Inner JOIN only the common values comes as output. if you wnat to use the command IS NULL to find the null values, it wont be possible, to avoid that and catch the null values, we use Left join

--3. I want to find the total number of students in each Major, but I only want to see Majors that have at least 10 students.
--Since we are using an Aggregate function here called SUM, we have to use having clause here because Having clause only executes after Select statement and WHERE would execute before SELECT statement which is why it will not be able to catch the value
--The Technical Distinction:
--WHERE filters individual rows before the data is grouped. It doesn't know what the "Sum" or "Count" is yet.

--HAVING filters the groups after the GROUP BY and aggregate functions (like COUNT or SUM) have been calculated.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--1.Write a query that shows each Category and the Total Revenue generated by that category.
SELECT 
    p.Category, 
    SUM(od.Quantity * od.UnitPrice) AS Total_Revenue
FROM Products1 p
JOIN OrderDetails od ON p.ProductID = od.ProductID
GROUP BY p.Category;
SELECT * FROM Products1;

--2.Show Name, StockQuantity, and a Status column ('Out of Stock', 'Low Stock', or 'In Stock').
Select Name, StockQuantity, CASE
	WHEN StockQuantity = 0 THEN 'Out Of Stock'
	WHEN StockQuantity <= 10 THEN 'Low Stock' --WHEN StockQuantity < 10 THEN 'Low Stock'
	When StockQuantity > 10 THEN 'In Stock' -- Else 'In Stock'
END as Status
FROM Products1;

--Find the names of products that have zero orders in the OrderDetails table.
Select p.Name
FROM Products1 p 
LEFT JOIN OrderDetails od 
ON p.ProductID = od.ProductID
WHere od.OrderID is NULL;

-- Write a query for ProductID 1 that shows:The DetailID from OrderDetails, The Quantity sold in that specific record, 
--A Running Total of the Quantity sold so far.
SELECT  DetailID, Quantity, SUM(Quantity) OVER (ORDER BY DetailID) as Running_Total
FROM OrderDetails
--WHERE ProductID = '1';

--Without ORDER BY: SUM(Quantity) OVER() gives you the Grand Total on every single row.
--With ORDER BY: SUM(Quantity) OVER(ORDER BY ID) gives you the Running Total.
--If you want the running total to restart for every new customer or every new month, you add PARTITION BY.
SELECT  DetailID, Quantity, SUM(Quantity) OVER (Partition by ProductID ORDER BY DetailID) as Running_Total
FROM OrderDetails;
--Show DetailID, Quantity, and Previous_Quantity. If there is no previous quantity, show 0.
SELECT  od.DetailID, od.Quantity, COALESCE(Lag(od.Quantity) OVER (ORDER BY od.DetailID),0) as Previous_Ouantity
FROM OrderDetails od;
--Once you see those zeros appearing correctly, do you want to try one last "Boss Battle" where we calculate the 
--difference between the current and previous quantity? (e.g., Quantity - Previous_Quantity)
SELECT  od.DetailID, od.Quantity, 
		COALESCE(Lag(od.Quantity) OVER (ORDER BY od.DetailID),0) as Previous_Ouantity, 
		od.Quantity - COALESCE(Lag(od.Quantity) OVER (ORDER BY od.DetailID),0) as Difference_Value
FROM OrderDetails od;
-- CTE
WITH VelocityData AS (
    SELECT DetailID, Quantity, COALESCE(LAG(Quantity) OVER (ORDER BY DetailID), 0) AS Prev
    FROM OrderDetails
)
SELECT 
    DetailID, Quantity, Prev AS Previous_Quantity,(Quantity - Prev) AS Difference_Value -- Much cleaner!
FROM VelocityData;

--Analyze the order-to-order momentum for our products. We want to see how much the sales volume is 
--increasing or decreasing as new orders come in.
With Velocity AS(
SELECT DetailID, Quantity, COALESCE(Lag(Quantity) OVER (ORDER BY DetailID),0) as Previous_Ouantity
FROM OrderDetails
)

SELECT DetailID, Quantity, 
		Previous_Ouantity,
		CASE 
        WHEN Previous_Ouantity = 0 THEN 0
        ELSE (Quantity - Previous_Ouantity) * 100.0 / Previous_Ouantity
    END AS Growth_Percentage
FROM Velocity;

