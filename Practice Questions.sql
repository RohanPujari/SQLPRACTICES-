--1."Find the First Name and Last Name of all authors who have written a book in the 'Horror' category. 
--Also, include the Title of those books in your results."
SELECT a.FirstName, a.LastName, b.Title 
FROM Authors as a
INNER JOIN Books as b
ON a.AuthorID = b.AuthorID
WHERE Category = 'Horror';

-- "I want to know which author has the most books in our store. Show me the First Name, Last Name, and
-- the Total Count of books for each author, sorted from highest to lowest."
SELECT  a.FirstName, a.LastName, Count(b.BookID ) as Total_Books
FROM Authors a 
JOIN Books b 
ON a.AuthorID = b.AuthorID
Group BY a.FirstName, a.LastName  
ORDER By Total_Books  DESC;



--3:"Find the First Name and Last Name of authors who have more than 1 book in our inventory. 
--Show their name and the count of their books."
SELECT  a.FirstName, a.LastName, Count(b.BookID ) as Total_Books
FROM Authors a 
JOIN Books b 
ON a.AuthorID = b.AuthorID
Group BY a.FirstName, a.LastName 
HAVING Total_Books >1
;

--4. "I want a list of Customers who have never placed an order. Show me their FirstName and LastName."
Select c.FirstName, c.LastName
FROM Customers c  
LEFT JOIN Orders o
On c.CustomerID = o.CustomerID 
Where o.OrderID IS NULL
;

--5. "Find the FirstName and LastName of customers who have placed an order that is larger than the 
--average of ALL orders in the system."
SELECT c.FirstName, c.LastName
from Customers c
JOIN Orders o 
ON c.CustomerID = o.CustomerID 
Where o.TotalAmount
 > (SELECT AVG(TotalAmount) as AVG_Amount
FROM Orders o )
;
--USing CTE
WITH AVGPrice as (Select AVG(TotalAmount) as AVGAMT FROM Orders o )
Select FirstName, LastName
FROM Customers c
JOIN Orders o 
ON c.CustomerID = o.CustomerID 
CROSS JOIN AVGPrice
WHERE o.TotalAmount > AVGPrice.AVGAMT;
--6. "I want a list of all Categories (from the Books table) and the Total Revenue 
--(sum of TotalAmount from the Orders table) generated by that category."
SELECT 
    b.Category, 
    SUM(o.TotalAmount) AS CategoryRevenue
FROM Books b
JOIN Orders o ON b.BookID = o.OrderID -- Assuming 1 order = 1 book for this practice
GROUP BY b.Category;
--THis questin is wrong because there is no common table bw Books and orders

--7. Rank the books by price within each category (highest price = Rank 1).

Select Title, Price, Category, RANK() OVER(Partition by Category Order by Price DESC) as Ranks
FROM Books;
--Okay, now show me ONLY the most expensive book in each category
Select Title, Price, Category, RANK() OVER(Partition by Category Order by Price DESC) as Ranks
FROM Books
Where Ranks < 2;
--This above code will not work because Ranks is created at the same time of the query filtering

--Correct Way:CTE
With Ranksbook as 
(Select Title, Price, Category, RANK() OVER(Partition by Category Order by Price DESC) as Ranks
FROM Books)  
Select * from Ranksbook 
Where Ranks = 1;

--8: List all Orders sorted by date. Include the OrderID, OrderDate, and TotalAmount. 
--Then, add a fourth column called RunningTotal that sums up the TotalAmount as it goes down the list.
SELECT OrderID, OrderDate, TotalAmount, SUM(TotalAmount) OVER( Order by OrderDate) as Running_Total
From Orders o 
--Notice that we don't use PARTITION BY here because we want one continuous sum for the whole store!

--9. Show each Category and the Title of the book with the lowest StockQuantity. If two books in 
--the same category have the same lowest stock, show both.

With Lowstock AS 
(Select Category, Title, StockQuantity, Rank() OVER(Partition by Category Order by StockQuantity) as Low_Stock
from Books)
Select * from Lowstock
WHERE Low_Stock = 1;


--10. Find the FirstName and LastName of customers who joined in 2023 but have never placed an order.
Select c.FirstName, c.LastName from Customers c 
LEFT JOIN Orders o 
ON o.CustomerID = c.CustomerID
WHERE c.JoinDate LIKE '2023%' and o.OrderID is NULL;


------------------------------------------------------------------------------
--All the tbles are not connected to each other, so lets connect them first. |
-- 1. Add the column to Orders												 |
ALTER TABLE Orders ADD COLUMN BookID INTEGER;							--	 |
																	--		 |
-- 2. "Connect" the data (Assigning books to the orders we already have)	 |
UPDATE Orders SET BookID = 101 WHERE OrderID = 501;						--	 |
UPDATE Orders SET BookID = 103 WHERE OrderID = 502;						--	 |
UPDATE Orders SET BookID = 102 WHERE OrderID = 503;					--		 |
																		--	 |		
-- 3. Verify it worked														 |
SELECT * FROM Orders;													--	 |		
------------------------------------------------------------------------------
--11. Show me the First Name and Last Name of every Author and the Total Revenue generated by their books.
Select a.FirstName , a.LastName, SUM(o.TotalAmount) As Total_Revenue 
FROM Authors a 
Left Join Books b ON b.AuthorID = a.AuthorID
Left JOIN Orders o 
ON b.BookID = o.BookID
GROUP BY a.FirstName , a.LastName;

--Find which Category (Genre) is the most popular based on the number of books sold (not the dollar amount).
	
Select b.Category, COUNT(o.OrderID ) AS Number_of_Sales
FROM Books b 
JOIN Orders o 
ON b.BookID  = o.BookID
GROUP BY b.Category 
ORDER BY Number_of_Sales DESC 

-- Find the FirstName and LastName of the customer who has spent the most money in total.
select c.FirstName, c.LastName, SUM(o.TotalAmount) as ttl
FROM Customers c 
JOIN Orders o 
ON o.CustomerID = c.CustomerID
GROUP BY c.FirstName , c.LastName
ORDER BY ttl DESC
LIMIT 1

--Find the Average Price of books in each Category.

SELECT b.Category ,  AVG(b.Price) as Avg_Price
FROM Books b 
Group BY b.Category;

-- Show me the FirstName and LastName of authors whose Average Book Price is greater than $20.

With AvgPrice AS(
SELECT a.Firstname, a.LastName, b.Category,  AVG(b.Price) as Avg_Price
FROM Books b
JOIN Authors a
ON b.AuthorID = a.AuthorID
Group BY a.Firstname, a.LastName, b.Category
)

Select Firstname, LastName
FROM AvgPrice
Where Avg_Price > 20;

-- Using Having Clause
SELECT a.FirstName, a.LastName
FROM Authors a
JOIN Books b ON a.AuthorID = b.AuthorID
GROUP BY a.FirstName, a.LastName
HAVING AVG(b.Price) > 20;

--WHERE looks at the raw data (e.g., "Is this one specific book over $20?").
--HAVING looks at the finished math (e.g., "Is the average of all these books over $20?").


--Show each Category and the Total Value of the stock (Price * StockQuantity). 
--Only show categories where that total is greater than 100.
Select b.Category, (b.Price*b.StockQuantity) as Total_Value
FROM Books b 
GROUP BY b.Category
Having Total_Value > 100;

--Find the FirstName and LastName of authors who have written more than 1 book in your Books table.
Select a.FirstName, a.LastName
From books b
JOIN Authors a
ON b.AuthorID = a.AuthorID
Group by b.AuthorID 
Having Count(b.AuthorID) > 1;
-- Find the Title of every book purchased by a customer named 'Alice' (or whoever is Customer #1 in your table), 
--and the LastName of the Author who wrote that book.
Select Title,  a.LastName, *
FROM Customers c 
JOIN Orders o 
ON c.CustomerID  = o.CustomerID
JOIN Books b 
ON b.BookID  = o.BookID
JOIN Authors a 
ON a.AuthorID = b.AuthorID
WHERE c.FirstName  = 'Alice';


--Show the Category and the Total Number of Books Sold in that category, but only for categories that have generated 
--more than $50 in total revenue. Sort by the number of books sold (highest first).

Select b.Category, COUNT(o.OrderID) as Total_BOOKS_SOLD
FROM Books b 
JOIN Orders o 
ON b.BookID  = o.BookID
GROUP BY b.Category
Having SUM(o.TotalAmount) > 50
Order BY Total_BOOKS_SOLD DESC;

-- Show the Category, Title, and Price, and then a new column called Category_Rank that ranks books from most 
--expensive to least expensive inside their own category.
SELECT b.Category , b.Title , b.Price, Rank() OVER(Partition by b.Category Order by b.Price DESC) as Category_Rank
FROM Books b;

--: Show every OrderID, OrderDate, and TotalAmount. Then, add a column called Running_Revenue that shows 
--the sum of all orders up to that date.
SELECT o.OrderID, o.OrderDate, o.TotalAmount, SUM(o.TotalAmount) OVER(Order BY o.OrderDate) as Running_Revenue
FROM Orders o

--Show the Title, Price, and a new column called Price_Segment.
--If Price is > 20$, the segment is 'Premium'.
--If Price is between 10$ and 20$, the segment is 'Standard'.
--Otherwise, the segment is 'Budget'.

SELECT Title, Price, CASE 
WHEN Price	> 20 THEN 'Premium'
WHEN Price >= 10 AND Price <= 20 THEN 'Standard'
ELSE 'BUDGET'
END as Price_Segment
FROM Books b ;

--Now, let's mix the Labeling (CASE), the Math (AGGREGATES), and the Ranking (WINDOW FUNCTIONS). 
--This is a "Full-Stack" SQL query.
--The Goal: We want a report of all authors that shows:
--FirstName and LastName.
--Experience_Level: If they have written more than 1 book, call them 'Prolific', otherwise 'Newcomer'.
--Price_Rank: A rank of authors based on their Average Book Price (highest average price = Rank 1).
WITH AuthorSummary AS (
    SELECT 
        a.FirstName, 
        a.LastName, 
        COUNT(b.BookID) AS TotalBooks,
        AVG(b.Price) AS AvgPrice
    FROM Authors a
    JOIN Books b ON a.AuthorID = b.AuthorID
    GROUP BY a.FirstName, a.LastName
)
SELECT FirstName, LastName,
    -- Labeling logic
    CASE WHEN TotalBooks > 1 THEN 'Prolific'
         ELSE 'Newcomer'
    END AS Experience_Level,
    -- Ranking logic (No PARTITION BY needed because we are ranking everyone against each other)
RANK() OVER (ORDER BY AvgPrice DESC) AS Price_Rank
FROM AuthorSummary;

--Show every OrderID, the TotalAmount, and the TotalAmount of the previous order.
SELECT OrderID, TotalAmount, LAG(TotalAmount) OVER (ORDER BY OrderDate) AS Previous_Order_Amount
FROM Orders;




